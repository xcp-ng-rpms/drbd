From c7567eb70ca4af11e75978a0a68b730c32fdcaa4 Mon Sep 17 00:00:00 2001
From: Lars Ellenberg <lars.ellenberg@linbit.com>
Date: Thu, 10 Oct 2024 19:01:26 +0200
Subject: [PATCH] Fix for 'Revert "drbd: rework autopromote"'

That revert was incomplete/incorrect, and introduced possible deadlocks:

  # echo >/dev/drbdX </dev/drbdX &
would deadlock in drbd_release() -> drbd_fsync_device() -> drbd_reject_write_early(),
and prevent any future access to the device until reboot.

  # drbdsetup primary X
  # mount -o ro /dev/drbdX /mnt
  # mount -o remount,rw /mnt
  # umount /mnt
  # drbdsetup down X
would leave the device "un-down-able" and locked in primary role.
If you repeat that long enough, you may even provoke a kernel crash.

  # drbdsetup resource-options --auto-promote=no X
  # drbdsetup secondary X
  # : > /dev/drbdX
would leave the device "un-down-able".
Again, with a little creativity you likely could provoke a kernel crash.

Introduce device->ro_cnt_is_write to handle the "remount" case.

Call drbd_fsync_device() before we decrease the open_*_cnt
to fix the potential deadlock.

Fix the compat layer to use the passed in "mode" instead of hardcoded 0
for drbd_release() in the error path of drbd_open().
---
 ...ns_release__no_takes_single_argument.cocci | 15 +++++--
 drbd/drbd_int.h                               |  1 +
 drbd/drbd_main.c                              | 40 +++++++++++++------
 drbd/drbd_req.c                               |  5 +--
 drbd/drbd_state.c                             |  5 ++-
 5 files changed, 44 insertions(+), 22 deletions(-)

diff --git a/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci b/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci
index 4c57be0b8..d24cf9a63 100644
--- a/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci
+++ b/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci
@@ -23,7 +23,14 @@ drbd_release(...)
 symbol drbd_release;
 expression gd;
 @@
-  drbd_release(
-  	gd
-+ 	, 0
-  )
+drbd_open(...)
+{
+...
+  if (err) {
+    drbd_release(gd
++ , mode
+    );
+    ...
+  }
+...
+}
diff --git a/drbd/drbd_int.h b/drbd/drbd_int.h
index 23df3953f..9dc33e689 100644
--- a/drbd/drbd_int.h
+++ b/drbd/drbd_int.h
@@ -1574,6 +1574,7 @@ struct drbd_device {
 
 	struct drbd_bitmap *bitmap;
 
+	bool ro_cnt_is_write; /* we want to deal with mount --remount,rw somehow */
 	int open_rw_cnt, open_ro_cnt;
 	/* FIXME clean comments, restructure so it is more obvious which
 	 * members are protected by what */
diff --git a/drbd/drbd_main.c b/drbd/drbd_main.c
index 5fa029580..ca946a23b 100644
--- a/drbd/drbd_main.c
+++ b/drbd/drbd_main.c
@@ -2916,7 +2916,10 @@ void drbd_open_counts(struct drbd_resource *resource, int *rw_count_ptr, int *ro
 	rcu_read_lock();
 	idr_for_each_entry(&resource->devices, device, vnr) {
 		rw_count += device->open_rw_cnt;
-		ro_count += device->open_ro_cnt;
+		if (device->ro_cnt_is_write)
+			rw_count += device->open_ro_cnt;
+		else
+			ro_count += device->open_ro_cnt;
 	}
 	rcu_read_unlock();
 	*rw_count_ptr = rw_count;
@@ -2989,26 +2992,37 @@ static void drbd_release(struct gendisk *gd)
 	/* This is a workaround for kernels that do not pass in the fmode_t argument.*/
 	fmode_t mode = device->open_ro_cnt ? FMODE_READ : FMODE_WRITE;
 
-	mutex_lock(&resource->open_release);
-	/* The last one to close already called sync_blockdevice(), generic
-	 * bdev_release() respectively blkdev_put_whole() takes care of that.
-	 * But we need to already flush when the last writer disappears,
-	 * even if some readers are still present.
-	 * We still want our side effects of drbd_fsync_device():
-	 * wait until all peers confirmed they have all the data, regardless of
-	 * replication protocol, even if that is asynchronous.
-	 * Still, do it before decreasing the open_cnt, just in case, so we
-	 * won't confuse drbd_reject_write_early() or other code paths that may
-	 * check for open_cnt != 0 when they see write requests.
+	/* Last writer to close will be responsible for write-out of all dirty pages.
+	 * If someone did a --remount,rw or similar, then we can no longer rely
+	 * on "ro_cnt" actually meaning read-only.
+	 * Do it before decreasing the open count to not confuse code paths
+	 * that check for open_*_cnt != 0 during write requests.
+	 * If we have a read-only opener that managed to "silently convert"
+	 * to write (mount -o remount,rw), and we have dirty pages, but not
+	 * seen any write yet with open_rw_cnt == 0, ro_cnt_is_write is still
+	 * false, and holding the mutex during fsync will run right into the
+	 * "mutex_lock" case in drbd_reject_write_early(), causing a deadlock.
 	 */
-	if (mode & FMODE_WRITE && device->open_rw_cnt == 1)
+	mutex_lock(&resource->open_release);
+	if (device->open_rw_cnt + device->open_ro_cnt == 1
+	|| (mode & FMODE_WRITE && device->open_rw_cnt == 1)) {
+		mutex_unlock(&resource->open_release);
+		/* If someone re-opened meanwhile, that's not a problem.
+		 * We can sync more than once.
+		 * But we must not miss the last one.
+		 */
 		drbd_fsync_device(device);
+		mutex_lock(&resource->open_release);
+	}
 
 	if (mode & FMODE_WRITE)
 		device->open_rw_cnt--;
 	else
 		device->open_ro_cnt--;
 
+	if (device->ro_cnt_is_write && device->open_ro_cnt == 0)
+		device->ro_cnt_is_write = false;
+
 	drbd_open_counts(resource, &open_rw_cnt, &open_ro_cnt);
 
 	if (open_ro_cnt == 0)
diff --git a/drbd/drbd_req.c b/drbd/drbd_req.c
index 311c4b1fb..8882b9709 100644
--- a/drbd/drbd_req.c
+++ b/drbd/drbd_req.c
@@ -2565,7 +2565,7 @@ static bool drbd_reject_write_early(struct drbd_device *device, struct bio *bio)
 		return true;
 	} else if (device->open_rw_cnt + device->open_ro_cnt == 0) {
 		drbd_err_ratelimit(device, "WRITE request, but open_cnt == 0!\n");
-	} else if (device->open_rw_cnt == 0 && bio_has_data(bio)) {
+	} else if (device->open_rw_cnt == 0 && !device->ro_cnt_is_write && bio_has_data(bio)) {
 		/*
 		 * If the resource was (temporarily, auto) promoted,
 		 * a remount,rw may have succeeded without marking the device
@@ -2577,8 +2577,7 @@ static bool drbd_reject_write_early(struct drbd_device *device, struct bio *bio)
 		mutex_lock(&resource->open_release);
 		drbd_info(device, "open_ro_cnt:%d, implicitly promoted to writable\n",
 			device->open_ro_cnt);
-		device->open_rw_cnt++;
-		device->open_ro_cnt--;
+		device->ro_cnt_is_write = true;
 		mutex_unlock(&resource->open_release);
 	}
 	return false;
diff --git a/drbd/drbd_state.c b/drbd/drbd_state.c
index 4fb33f87e..6dd761165 100644
--- a/drbd/drbd_state.c
+++ b/drbd/drbd_state.c
@@ -1641,7 +1641,7 @@ handshake_found:
 				return SS_TWO_PRIMARIES;
 			if (!fail_io[NEW]) {
 				idr_for_each_entry(&resource->devices, device, vnr) {
-					if (device->open_ro_cnt)
+					if (!device->ro_cnt_is_write && device->open_ro_cnt)
 						return SS_PRIMARY_READER;
 					/*
 					 * One might be tempted to add "|| open_rw_cont" here.
@@ -1668,7 +1668,8 @@ handshake_found:
 		     (disk_state[OLD] > D_DETACHING && disk_state[NEW] == D_DETACHING)))
 			return SS_IN_TRANSIENT_STATE;
 
-		if (role[OLD] == R_PRIMARY && role[NEW] == R_SECONDARY && device->open_rw_cnt &&
+		if (role[OLD] == R_PRIMARY && role[NEW] == R_SECONDARY &&
+		    (device->open_rw_cnt || (device->ro_cnt_is_write && device->open_ro_cnt)) &&
 		    !(resource->state_change_flags & CS_FS_IGN_OPENERS))
 			return SS_DEVICE_IN_USE;
 
