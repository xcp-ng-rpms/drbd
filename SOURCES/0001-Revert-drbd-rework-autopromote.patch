From adf72cc18024caa60cd2cac764701de5e2eb2b74 Mon Sep 17 00:00:00 2001
From: Philipp Reisner <philipp.reisner@linbit.com>
Date: Fri, 5 Jul 2024 12:00:09 +0200
Subject: [PATCH] Revert "drbd: rework autopromote"

This reverts commit e3ef0e229a6ae88346164d1507697ae1b397cdf9.
and adapts the compat code as neccessary.

This change brings back the exact tracking of read-only and read-write
openers.
---
 ...ns_release__no_takes_single_argument.cocci | 14 +++++-
 drbd/drbd_int.h                               |  3 +-
 drbd/drbd_main.c                              | 48 +++++++++++--------
 drbd/drbd_nl.c                                | 24 +++++-----
 drbd/drbd_req.c                               | 11 +++--
 drbd/drbd_state.c                             |  7 ++-
 6 files changed, 62 insertions(+), 45 deletions(-)

diff --git a/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci b/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci
index b0a0ee9ee..4c57be0b8 100644
--- a/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci
+++ b/drbd/drbd-kernel-compat/cocci/block_device_operations_release__no_takes_single_argument.cocci
@@ -3,10 +3,22 @@ identifier gd;
 fresh identifier mode = "" ## "mode";
 @@
   drbd_release(
-  	struct gendisk *gd
+	struct gendisk *gd
 + 	, fmode_t mode
   ) { ... }
 
+
+// remove the local variable mode, so that it does not shadow the parameter mode
+@@
+expression ex;
+@@
+drbd_release(...)
+{
+...
+- fmode_t mode = ex;
+...
+}
+
 @@
 symbol drbd_release;
 expression gd;
diff --git a/drbd/drbd_int.h b/drbd/drbd_int.h
index abeede189..ebe1b38e5 100644
--- a/drbd/drbd_int.h
+++ b/drbd/drbd_int.h
@@ -1581,8 +1581,7 @@ struct drbd_device {
 
 	struct drbd_bitmap *bitmap;
 
-	int open_cnt;
-	bool writable;
+	int open_rw_cnt, open_ro_cnt;
 	/* FIXME clean comments, restructure so it is more obvious which
 	 * members are protected by what */
 
diff --git a/drbd/drbd_main.c b/drbd/drbd_main.c
index dd1fb2fe4..2a1e23c15 100644
--- a/drbd/drbd_main.c
+++ b/drbd/drbd_main.c
@@ -2724,16 +2724,17 @@ static enum ioc_rv inc_open_count(struct drbd_device *device, blk_mode_t mode)
 		r = IOC_ABORT;
 	else if (resource->remote_state_change &&
 		resource->role[NOW] != R_PRIMARY &&
-		(device->open_cnt == 0 || mode & BLK_OPEN_WRITE)) {
+		(device->open_ro_cnt == 0 || mode & BLK_OPEN_WRITE)) {
 		if (mode & BLK_OPEN_NDELAY)
 			r = IOC_ABORT;
 		else
 			r = IOC_SLEEP;
 	} else {
 		r = IOC_OK;
-		device->open_cnt++;
-		if (mode & BLK_OPEN_WRITE)
-			device->writable = true;
+		if (mode & FMODE_WRITE)
+			device->open_rw_cnt++;
+		else
+			device->open_ro_cnt++;
 	}
 	read_unlock_irq(&resource->state_rwlock);
 
@@ -2813,7 +2814,6 @@ static int drbd_open(struct gendisk *gd, blk_mode_t mode)
 	struct drbd_resource *resource = device->resource;
 	long timeout = resource->res_opts.auto_promote_timeout * HZ / 10;
 	enum drbd_state_rv rv = SS_UNKNOWN_ERROR;
-	bool was_writable;
 	enum ioc_rv r;
 	int err = 0;
 
@@ -2837,7 +2837,6 @@ static int drbd_open(struct gendisk *gd, blk_mode_t mode)
 	kref_debug_get(&device->kref_debug, 3);
 
 	mutex_lock(&resource->open_release);
-	was_writable = device->writable;
 
 	timeout = wait_event_interruptible_timeout(resource->twopc_wait,
 						   (r = inc_open_count(device, mode)),
@@ -2901,7 +2900,7 @@ out:
 	if (!err) {
 		add_opener(device, rv >= SS_SUCCESS);
 		/* Only interested in first open and last close. */
-		if (device->open_cnt == 1) {
+		if (device->open_ro_cnt + device->open_rw_cnt == 1) {
 			struct device_info info;
 
 			device_to_info(&info, device);
@@ -2909,8 +2908,7 @@ out:
 			notify_device_state(NULL, 0, device, &info, NOTIFY_CHANGE);
 			mutex_unlock(&notification_mutex);
 		}
-	} else
-		device->writable = was_writable;
+	}
 
 	mutex_unlock(&resource->open_release);
 	if (err) {
@@ -2929,10 +2927,8 @@ void drbd_open_counts(struct drbd_resource *resource, int *rw_count_ptr, int *ro
 
 	rcu_read_lock();
 	idr_for_each_entry(&resource->devices, device, vnr) {
-		if (device->writable)
-			rw_count += device->open_cnt;
-		else
-			ro_count += device->open_cnt;
+		rw_count += device->open_rw_cnt;
+		ro_count += device->open_ro_cnt;
 	}
 	rcu_read_unlock();
 	*rw_count_ptr = rw_count;
@@ -3002,9 +2998,14 @@ static void drbd_release(struct gendisk *gd)
 	struct drbd_resource *resource = device->resource;
 	int open_rw_cnt, open_ro_cnt;
 
+	/* This is a workaround for kernels that do not pass in the fmode_t argument.*/
+	fmode_t mode = device->open_ro_cnt ? FMODE_READ : FMODE_WRITE;
+
 	mutex_lock(&resource->open_release);
 	/* The last one to close already called sync_blockdevice(), generic
 	 * bdev_release() respectively blkdev_put_whole() takes care of that.
+	 * But we need to already flush when the last writer disappears,
+	 * even if some readers are still present.
 	 * We still want our side effects of drbd_fsync_device():
 	 * wait until all peers confirmed they have all the data, regardless of
 	 * replication protocol, even if that is asynchronous.
@@ -3012,17 +3013,21 @@ static void drbd_release(struct gendisk *gd)
 	 * won't confuse drbd_reject_write_early() or other code paths that may
 	 * check for open_cnt != 0 when they see write requests.
 	 */
-	if (device->writable && device->open_cnt == 1) {
+	if (mode & FMODE_WRITE && device->open_rw_cnt == 1)
 		drbd_fsync_device(device);
-		device->writable = false;
-	}
-	device->open_cnt--;
+
+	if (mode & FMODE_WRITE)
+		device->open_rw_cnt--;
+	else
+		device->open_ro_cnt--;
+
 	drbd_open_counts(resource, &open_rw_cnt, &open_ro_cnt);
 
 	if (open_ro_cnt == 0)
 		wake_up_all(&resource->state_wait);
 
-	if (test_bit(UNREGISTERED, &device->flags) && device->open_cnt == 0 &&
+	if (test_bit(UNREGISTERED, &device->flags) &&
+	    device->open_rw_cnt == 0 && device->open_ro_cnt == 0 &&
 	    !test_and_set_bit(DESTROYING_DEV, &device->flags))
 		call_rcu(&device->rcu, drbd_reclaim_device);
 
@@ -3063,11 +3068,12 @@ static void drbd_release(struct gendisk *gd)
 		end_state_change(resource, &irq_flags, "release");
 	}
 
-	/* if the open count is 0, we free the whole list, otherwise we remove the specific pid */
-	prune_or_free_openers(device, (device->open_cnt == 0) ? 0 : task_pid_nr(current));
+	/* if the open counts are 0, we free the whole list, otherwise we remove the specific pid */
+	prune_or_free_openers(device,
+			(open_ro_cnt == 0 && open_rw_cnt == 0) ? 0 : task_pid_nr(current));
 	if (open_rw_cnt == 0 && open_ro_cnt == 0 && resource->auto_promoted_by.pid != 0)
 		memset(&resource->auto_promoted_by, 0, sizeof(resource->auto_promoted_by));
-	if (device->open_cnt == 0) {
+	if (open_ro_cnt == 0 && open_rw_cnt == 0) {
 		struct device_info info;
 
 		device_to_info(&info, device);
diff --git a/drbd/drbd_nl.c b/drbd/drbd_nl.c
index 6264e809b..811c0a817 100644
--- a/drbd/drbd_nl.c
+++ b/drbd/drbd_nl.c
@@ -1272,9 +1272,10 @@ void youngest_and_oldest_opener_to_str(struct drbd_device *device, char *buf, si
 
 	buf[0] = '\0';
 	/* Do we have opener information? */
-	if (!device->open_cnt)
+	if (!(device->open_ro_cnt + device->open_rw_cnt))
 		return;
-	cnt = snprintf(buf, len, " open_cnt:%d", device->open_cnt);
+	cnt = snprintf(buf, len, " open_ro_cnt:%d open_rw_cnt:%d",
+		       device->open_ro_cnt, device->open_rw_cnt);
 	if (cnt > 0 && cnt < len) {
 		buf += cnt;
 		len -= cnt;
@@ -1297,7 +1298,7 @@ void youngest_and_oldest_opener_to_str(struct drbd_device *device, char *buf, si
 			ts = ktime_to_timespec64(last->opened);
 			time64_to_tm(ts.tv_sec, -sys_tz.tz_minuteswest * 60, &tm);
 			snprintf(buf, len, "%s%s:%d:%04ld-%02d-%02d_%02d:%02d:%02d.%03ld]",
-			      device->open_cnt > 2 ? ", ..., " : ", ",
+			      device->open_ro_cnt + device->open_rw_cnt > 2 ? ", ..., " : ", ",
 			      last->comm, last->pid,
 			      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
 			      tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec / NSEC_PER_MSEC);
@@ -1315,13 +1316,13 @@ static int put_device_opener_info(struct drbd_device *device, struct sk_buff *re
 	char *dotdotdot = "";
 
 	spin_lock(&device->openers_lock);
-	if (!device->open_cnt) {
+	if (!(device->open_ro_cnt + device->open_rw_cnt)) {
 		spin_unlock(&device->openers_lock);
 		return cnt;
 	}
 	drbd_msg_sprintf_info(reply_skb,
-		"/dev/drbd%d open_cnt:%d, writable:%d; list of openers follows",
-		device->minor, device->open_cnt, device->writable);
+		"/dev/drbd%d open_ro_cnt:%d, open_rw_cnt:%d; list of openers follows",
+		device->minor, device->open_ro_cnt, device->open_rw_cnt);
 	list_for_each_entry(o, &device->openers, list) {
 		ts = ktime_to_timespec64(o->opened);
 		time64_to_tm(ts.tv_sec, -sys_tz.tz_minuteswest * 60, &tm);
@@ -4254,7 +4255,7 @@ static void __device_to_info(struct device_info *info,
 			     struct drbd_device *device)
 {
 	info->is_intentional_diskless = device->device_conf.intentional_diskless;
-	info->dev_is_open = device->open_cnt != 0;
+	info->dev_is_open = device->open_ro_cnt + device->open_rw_cnt != 0;
 
 	rcu_read_lock();
 	if (get_ldev(device)) {
@@ -4911,10 +4912,8 @@ int drbd_open_ro_count(struct drbd_resource *resource)
 	int vnr, open_ro_cnt = 0;
 
 	read_lock_irq(&resource->state_rwlock);
-	idr_for_each_entry(&resource->devices, device, vnr) {
-		if (!device->writable)
-			open_ro_cnt += device->open_cnt;
-	}
+	idr_for_each_entry(&resource->devices, device, vnr)
+		open_ro_cnt += device->open_ro_cnt;
 	read_unlock_irq(&resource->state_rwlock);
 
 	return open_ro_cnt;
@@ -7091,7 +7090,8 @@ static enum drbd_ret_code adm_del_minor(struct drbd_device *device)
 	notify_device_state(NULL, 0, device, NULL, NOTIFY_DESTROY);
 	mutex_unlock(&notification_mutex);
 
-	if (device->open_cnt == 0 && !test_and_set_bit(DESTROYING_DEV, &device->flags))
+	if (device->open_ro_cnt == 0 && device->open_rw_cnt == 0 &&
+	    !test_and_set_bit(DESTROYING_DEV, &device->flags))
 		call_rcu(&device->rcu, drbd_reclaim_device);
 
 	return ret;
diff --git a/drbd/drbd_req.c b/drbd/drbd_req.c
index 856adf7d2..feff59d65 100644
--- a/drbd/drbd_req.c
+++ b/drbd/drbd_req.c
@@ -2568,9 +2568,9 @@ static bool drbd_reject_write_early(struct drbd_device *device, struct bio *bio)
 			kfree(buf);
 		}
 		return true;
-	} else if (device->open_cnt == 0) {
+	} else if (device->open_rw_cnt + device->open_ro_cnt == 0) {
 		drbd_err_ratelimit(device, "WRITE request, but open_cnt == 0!\n");
-	} else if (!device->writable && bio_has_data(bio)) {
+	} else if (device->open_rw_cnt == 0 && bio_has_data(bio)) {
 		/*
 		 * If the resource was (temporarily, auto) promoted,
 		 * a remount,rw may have succeeded without marking the device
@@ -2580,9 +2580,10 @@ static bool drbd_reject_write_early(struct drbd_device *device, struct bio *bio)
 		 * mutex to protect against races with new openers.
 		 */
 		mutex_lock(&resource->open_release);
-		drbd_info(device, "open_cnt:%d, implicitly promoted to writable\n",
-			device->open_cnt);
-		device->writable = true;
+		drbd_info(device, "open_ro_cnt:%d, implicitly promoted to writable\n",
+			device->open_ro_cnt);
+		device->open_rw_cnt++;
+		device->open_ro_cnt--;
 		mutex_unlock(&resource->open_release);
 	}
 	return false;
diff --git a/drbd/drbd_state.c b/drbd/drbd_state.c
index 08a74f904..4fb33f87e 100644
--- a/drbd/drbd_state.c
+++ b/drbd/drbd_state.c
@@ -1641,7 +1641,7 @@ handshake_found:
 				return SS_TWO_PRIMARIES;
 			if (!fail_io[NEW]) {
 				idr_for_each_entry(&resource->devices, device, vnr) {
-					if (!device->writable && device->open_cnt)
+					if (device->open_ro_cnt)
 						return SS_PRIMARY_READER;
 					/*
 					 * One might be tempted to add "|| open_rw_cont" here.
@@ -1668,7 +1668,7 @@ handshake_found:
 		     (disk_state[OLD] > D_DETACHING && disk_state[NEW] == D_DETACHING)))
 			return SS_IN_TRANSIENT_STATE;
 
-		if (role[OLD] == R_PRIMARY && role[NEW] == R_SECONDARY && device->writable &&
+		if (role[OLD] == R_PRIMARY && role[NEW] == R_SECONDARY && device->open_rw_cnt &&
 		    !(resource->state_change_flags & CS_FS_IGN_OPENERS))
 			return SS_DEVICE_IN_USE;
 
@@ -1700,8 +1700,7 @@ handshake_found:
 			return SS_NO_UP_TO_DATE_DISK;
 
 		/* Prevent detach or disconnect while held open read only */
-		if (!device->writable && device->open_cnt &&
-		    any_disk_up_to_date[OLD] && !any_disk_up_to_date[NEW])
+		if (device->open_ro_cnt && any_disk_up_to_date[OLD] && !any_disk_up_to_date[NEW])
 			return SS_NO_UP_TO_DATE_DISK;
 
 		if (disk_state[NEW] == D_NEGOTIATING)
